.\" Automatically generated by Pod::Man 4.09 (Pod::Simple 3.35)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
.    ds C`
.    ds C'
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is >0, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.\"
.\" Avoid warning from groff about undefined register 'F'.
.de IX
..
.if !\nF .nr F 0
.if \nF>0 \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    if !\nF==2 \{\
.        nr % 0
.        nr F 2
.    \}
.\}
.\" ========================================================================
.\"
.IX Title "Locale::Messages 3pm"
.TH Locale::Messages 3pm "2020-10-14" "perl v5.26.1" "User Contributed Perl Documentation"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
Locale::Messages \- Gettext Like Message Retrieval
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\& use Locale::Messages qw(:locale_h :libintl_h);
\&
\& gettext $msgid;
\& dgettext $textdomain, $msgid;
\& dcgettext $textdomain, $msgid, LC_MESSAGES;
\& ngettext $msgid, $msgid_plural, $count;
\& dngettext $textdomain, $msgid, $msgid_plural, $count;
\& dcngettext $textdomain, $msgid, $msgid_plural, $count, LC_MESSAGES;
\& pgettext $msgctxt, $msgid;
\& dpgettext $textdomain, $msgctxt, $msgid;
\& dcpgettext $textdomain, $msgctxt, $msgid, LC_MESSAGES;
\& npgettext $msgctxt, $msgid, $msgid_plural, $count;
\& dnpgettext $textdomain, $msgctxt, $msgid, $msgid_plural, $count;
\& dcnpgettext $textdomain, $msgctxt, $msgid, $msgid_plural, $count, LC_MESSAGES;
\& textdomain $textdomain;
\& bindtextdomain $textdomain, $directory;
\& bind_textdomain_codeset $textdomain, $encoding;
\& bind_textdomain_filter $textdomain, \e&filter, $data;
\& turn_utf_8_on ($variable);
\& turn_utf_8_off ($variable);
\& nl_putenv (\*(AqOUTPUT_CHARSET=koi8\-r\*(Aq);
\& my $category = LC_CTYPE;
\& my $category = LC_NUMERIC;
\& my $category = LC_TIME;
\& my $category = LC_COLLATE;
\& my $category = LC_MONETARY;
\& my $category = LC_MESSAGES;
\& my $category = LC_ALL;
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
The module \fBLocale::Messages\fR is a wrapper around the interface to
message translation according to the Uniforum approach that is
for example used in \s-1GNU\s0 gettext and Sun's Solaris.  It is intended
to allow \fILocale::Messages\fR\|(3) to switch between different implementations
of the lower level libraries but this is not yet implemented.
.PP
Normally you should not use this module directly, but the high
level interface \fILocale::TextDomain\fR\|(3) that provides a much simpler
interface.  This description is therefore deliberately kept
brief.  Please refer to the \s-1GNU\s0 gettext documentation available at
<http://www.gnu.org/manual/gettext/> for in-depth and background 
information on the topic.
.PP
The lower level module \fILocale::gettext_pp\fR\|(3) provides the Perl
implementation of \fIgettext()\fR and related functions.
.SH "FUNCTIONS"
.IX Header "FUNCTIONS"
The module exports by default nothing.  Every function has to be
imported explicitely or via an export tag (\*(L"\s-1EXPORT TAGS\*(R"\s0).
.IP "\fBgettext \s-1MSGID\s0\fR" 4
.IX Item "gettext MSGID"
Returns the translation for \fB\s-1MSGID\s0\fR.  Example:
.Sp
.Vb 1
\&    print gettext "Hello World!\en";
.Ve
.Sp
If no translation can be found, the unmodified \fB\s-1MSGID\s0\fR is returned,
i. e. the function can \fInever\fR fail, and will \fInever\fR mess up your
original message.
.Sp
Note for Perl 5.6 and later: The returned string will \fIalways\fR have
the \s-1UTF\-8\s0 flag off by default.  See the documentation for function
\&\fIbind_textdomain_filter()\fR for a way to change this behavior.
.Sp
One common mistake is this:
.Sp
.Vb 1
\&    print gettext "Hello $name!";
.Ve
.Sp
Perl will interpolate the variable \f(CW$name\fR \fIbefore\fR the function
will see the string.  Unless the corresponding message catalog 
contains a message \*(L"Hello Tom!\*(R", \*(L"Hello Dick!\*(R" or \*(L"Hello Harry!\*(R",
no translation will be found.
.Sp
Using \fIprintf()\fR and friends has its own problems:
.Sp
.Vb 1
\&    print sprintf (gettext ("This is the %s %s."), $color, $thing);
.Ve
.Sp
(The example is stupid because neither color nor thing will get
translated here ...).
.Sp
In English the adjective (the color) will precede the noun, many
other languages (for example French or Italian) differ here.  The 
translator of the message may therefore have a hard time to find
a translation that will still work and not sound stupid in the 
target language.  Many C implementations of \fIprintf()\fR allow to 
change the order of the arguments, and a French translator could
then say:
.Sp
.Vb 1
\&    "C\*(Aqest le %2$s %1$s."
.Ve
.Sp
Perl \fIprintf()\fR implements this feature as of version 5.8 or better.
Consequently you can only use it, if you are sure that your software
will run with Perl 5.8 or a later version.
.Sp
Another disadvantage of using \fIprintf()\fR is its cryptic syntax (maybe
not for you but translators of your software may have their own
opinion).
.Sp
See the description of the function \f(CW\*(C`_\|_x()\*(C'\fR in \fILocale::TextDomain\fR\|(3)
for a much better way to get around this problem.
.Sp
Non-ASCII message ids ...
.Sp
You should note that the function (and all other similar functions
in this module) does a bytewise comparison of the \fB\s-1MSGID\s0\fR for the
lookup in the translation catalog, no matter whether obscure utf\-8
flags are set on it, whether the string looks like utf\-8, whether
the \fIutf8\fR\|(3pm) pragma is used, or whatever other weird method past
or future \fIperl\fR\|(1) versions invent for guessing character sets of
strings.
.Sp
Using other than us-ascii characters in Perl source code is a call
for trouble, a compatibility nightmare.  Furthermore, \s-1GNU\s0 gettext
only lately introduced support for non-ascii character sets in sources,
and support for this feature may not be available everywhere.  If
you absolutely want to use \fB\s-1MSGID\s0\fRs in non-ascii character sets,
it is wise to choose utf\-8.  This will minimize the risk that \fIperl\fR\|(1)
itself will mess with the strings, and it will also be a guaranty
that you can later translate your project into arbitrary target
languages.
.Sp
Other character sets can theoretically work.  Yet, using another
character set in the Perl source code than the one used in your
message catalogs will \fBnever\fR work, since the lookup is done bytewise,
and all strings with non-ascii characters will not be found.
.Sp
Even if you have solved all these problems, there is still one show
stopper left: The gettext runtime \s-1API\s0 lacks a possibility to specify 
the character set of the source code (including the original strings).
Consequently \- in absence of a hint for the input encoding \- strings 
without a translation are not subject to output character set conversion.
In other words: If the (non-determinable) output character set differs
from the character set used in the source code, output can be a
mixture of two character sets.  There is no point in trying to address
this problem in the pure Perl version of the gettext functions.  because
breaking compatibilty between the Perl and the C version is a price too
high to pay.
.Sp
This all boils down to: Only use \s-1ASCII\s0 characters in your translatable
strings!
.IP "\fBdgettext \s-1TEXTDOMAIN, MSGID\s0\fR" 4
.IX Item "dgettext TEXTDOMAIN, MSGID"
Like \fIgettext()\fR, but retrieves the message for the specified 
\&\fB\s-1TEXTDOMAIN\s0\fR instead of the default domain.  In case you wonder what
a textdomain is, you should really read on with \fILocale::TextDomain\fR\|(3).
.IP "\fBdcgettext \s-1TEXTDOMAIN, MSGID, CATEGORY\s0\fR" 4
.IX Item "dcgettext TEXTDOMAIN, MSGID, CATEGORY"
Like \fIdgettext()\fR but retrieves the message from the specified \fB\s-1CATEGORY\s0\fR
instead of the default category \f(CW\*(C`LC_MESSAGES\*(C'\fR.
.IP "\fBngettext \s-1MSGID, MSGID_PLURAL, COUNT\s0\fR" 4
.IX Item "ngettext MSGID, MSGID_PLURAL, COUNT"
Retrieves the correct translation for \fB\s-1COUNT\s0\fR items.  In legacy software
you will often find something like:
.Sp
.Vb 1
\&    print "$count file(s) deleted.\en";
.Ve
.Sp
or
.Sp
.Vb 1
\&    printf "$count file%s deleted.\en", $count == 1 ? \*(Aq\*(Aq : \*(Aqs\*(Aq;
.Ve
.Sp
The first example looks awkward, the second will only work in English
and languages with similar plural rules.  Before \fIngettext()\fR was introduced,
the best practice for internationalized programs was:
.Sp
.Vb 5
\&    if ($count == 1) {
\&        print gettext "One file deleted.\en";
\&    } else {
\&        printf gettext "%d files deleted.\en";
\&    }
.Ve
.Sp
This is a nuisance for the programmer and often still not sufficient
for an adequate translation.  Many languages have completely different
ideas on numerals.  Some (French, Italian, ...) treat 0 and 1 alike,
others make no distinction at all (Japanese, Korean, Chinese, ...),
others have two or more plural forms (Russian, Latvian, Czech,
Polish, ...).  The solution is:
.Sp
.Vb 4
\&    printf (ngettext ("One file deleted.\en",
\&                     "%d files deleted.\en",
\&                     $count), # argument to ngettext!
\&            $count);          # argument to printf!
.Ve
.Sp
In English, or if no translation can be found, the first argument
(\fB\s-1MSGID\s0\fR) is picked if \f(CW$count\fR is one, the second one otherwise.
For other languages, the correct plural form (of 1, 2, 3, 4, ...)
is automatically picked, too.  You don't have to know anything about
the plural rules in the target language, \fIngettext()\fR will take care
of that.
.Sp
This is most of the time sufficient but you will have to prove your
creativity in cases like
.Sp
.Vb 1
\&    printf "%d file(s) deleted, and %d file(s) created.\en";
.Ve
.IP "\fBdngettext \s-1TEXTDOMAIN, MSGID, MSGID_PLURAL, COUNT\s0\fR" 4
.IX Item "dngettext TEXTDOMAIN, MSGID, MSGID_PLURAL, COUNT"
Like \fIngettext()\fR but retrieves the translation from the specified
textdomain instead of the default domain.
.IP "\fBdcngettext \s-1TEXTDOMAIN, MSGID, MSGID_PLURAL, COUNT, CATEGORY\s0\fR" 4
.IX Item "dcngettext TEXTDOMAIN, MSGID, MSGID_PLURAL, COUNT, CATEGORY"
Like \fIdngettext()\fR but retrieves the translation from the specified
category, instead of the default category \f(CW\*(C`LC_MESSAGES\*(C'\fR.
.IP "\fBpgettext \s-1MSGCTXT, MSGID\s0\fR" 4
.IX Item "pgettext MSGCTXT, MSGID"
Returns the translation of \s-1MSGID,\s0 given the context of \s-1MSGCTXT.\s0
.Sp
Both items are used as a unique key into the message catalog.
.Sp
This allows the translator to have two entries for words that may
translate to different foreign words based on their context. For
example, the word \*(L"View\*(R" may be a noun or a verb, which may be
used in a menu as File\->View or View\->Source.
.Sp
.Vb 2
\&    pgettext "Verb: To View", "View\en";
\&    pgettext "Noun: A View", "View\en";
.Ve
.Sp
The above will both lookup different entries in the message catalog.
.Sp
A typical usage are \s-1GUI\s0 programs.  Imagine a program with a main
menu and the notorious \*(L"Open\*(R" entry in the \*(L"File\*(R" menu.  Now imagine,
there is another menu entry Preferences\->Advanced\->Policy where you have 
a choice between the alternatives \*(L"Open\*(R" and \*(L"Closed\*(R".  In English, \*(L"Open\*(R"
is the adequate text at both places.  In other languages, it is very
likely that you need two different translations.  Therefore, you would
now write:
.Sp
.Vb 2
\&    pgettext "File|", "Open";
\&    pgettext "Preferences|Advanced|Policy", "Open";
.Ve
.Sp
In English, or if no translation can be found, the second argument
(\s-1MSGID\s0) is returned.
.Sp
The function was introduced with libintl-perl version 1.17.
.IP "\fBdpgettext \s-1TEXTDOMAIN, MSGCTXT, MSGID\s0\fR" 4
.IX Item "dpgettext TEXTDOMAIN, MSGCTXT, MSGID"
Like \fIpgettext()\fR, but retrieves the message for the specified 
\&\fB\s-1TEXTDOMAIN\s0\fR instead of the default domain.
.Sp
The function was introduced with libintl-perl version 1.17.
.IP "\fBdcpgettext \s-1TEXTDOMAIN, MSGCTXT, MSGID, CATEGORY\s0\fR" 4
.IX Item "dcpgettext TEXTDOMAIN, MSGCTXT, MSGID, CATEGORY"
Like \fIdpgettext()\fR but retrieves the message from the specified \fB\s-1CATEGORY\s0\fR
instead of the default category \f(CW\*(C`LC_MESSAGES\*(C'\fR.
.Sp
The function was introduced with libintl-perl version 1.17.
.IP "\fBnpgettext \s-1MSGCTXT, MSGID, MSGID_PLURAL, COUNT\s0\fR" 4
.IX Item "npgettext MSGCTXT, MSGID, MSGID_PLURAL, COUNT"
Like \fIngettext()\fR with the addition of context as in \fIpgettext()\fR.
.Sp
In English, or if no translation can be found, the second argument
(\s-1MSGID\s0) is picked if \f(CW$count\fR is one, the third one otherwise.
.Sp
The function was introduced with libintl-perl version 1.17.
.IP "\fBdnpgettext \s-1TEXTDOMAIN, MSGCTXT, MSGID, MSGID_PLURAL, COUNT\s0\fR" 4
.IX Item "dnpgettext TEXTDOMAIN, MSGCTXT, MSGID, MSGID_PLURAL, COUNT"
Like \fInpgettext()\fR but retrieves the translation from the specified
textdomain instead of the default domain.
.Sp
The function was introduced with libintl-perl version 1.17.
.IP "\fBdcnpgettext \s-1TEXTDOMAIN, MSGCTXT, MSGID, MSGID_PLURAL, COUNT, CATEGORY\s0\fR" 4
.IX Item "dcnpgettext TEXTDOMAIN, MSGCTXT, MSGID, MSGID_PLURAL, COUNT, CATEGORY"
Like \fIdnpgettext()\fR but retrieves the translation from the specified
category, instead of the default category \f(CW\*(C`LC_MESSAGES\*(C'\fR.
.Sp
The function was introduced with libintl-perl version 1.17.
.IP "\fBtextdomain \s-1TEXTDOMAIN\s0\fR" 4
.IX Item "textdomain TEXTDOMAIN"
Sets the default textdomain (initially 'messages').
.IP "\fBbindtextdomain \s-1TEXTDOMAIN, DIRECTORY\s0\fR" 4
.IX Item "bindtextdomain TEXTDOMAIN, DIRECTORY"
Binds \fB\s-1TEXTDOMAIN\s0\fR to \fB\s-1DIRECTORY\s0\fR.  Huh? An example:
.Sp
.Vb 1
\&    bindtextdomain "my\-package", "./mylocale";
.Ve
.Sp
Say, the selected locale (actually the selected locale for category
\&\f(CW\*(C`LC_MESSAGES\*(C'\fR) of the program is 'fr_CH', then the message catalog
will be expected in \fI./mylocale/fr_CH/LC_MESSAGES/my\-package.mo\fR.
.IP "\fBbind_textdomain_codeset \s-1TEXTDOMAIN, ENCODING\s0\fR" 4
.IX Item "bind_textdomain_codeset TEXTDOMAIN, ENCODING"
Sets the output encoding for \fB\s-1TEXTDOMAIN\s0\fR to \fB\s-1ENCODING\s0\fR.
.IP "\fBbind_textdomain_filter \s-1TEXTDOMAN, CODEREF, DATA\s0\fR" 4
.IX Item "bind_textdomain_filter TEXTDOMAN, CODEREF, DATA"
.PD 0
.IP "\fBbind_textdomain_filter \s-1TEXTDOMAN, CODEREF\s0\fR" 4
.IX Item "bind_textdomain_filter TEXTDOMAN, CODEREF"
.PD
By default, Locale::Messages will turn the utf\-8 flag of all returned
messages off.  If you want to change this behavior, you can pass
a reference to a subroutine that does different things \- for example
turn the utf\-8 flag on, or leave it untouched.  The callback function 
will be called with \fB\s-1DATA\s0\fR as the first, and the possibly 
translated string as the second argument.  It should return the
possibly modified string.
.Sp
If you want an object method to be called, pass the object itself
in the data parameter and write a wrapper function.  Example:
.Sp
.Vb 2
\&    sub wrapper { 
\&        my ($string, $obj) = @_;
\& 
\&        $obj\->filterMethod ($string);
\&    }
\&    my $obj = MyPackage\->new;
\&
\&    bind_textdomain_filter (\*(Aqmydomain\*(Aq, \e&wrapper, $obj);
.Ve
.Sp
The function cannot fail and always returns a true value.
.Sp
\&\fBAttention:\fR If you use the function for setting the utf\-8 flag,
it is \fByour\fR responsability to ensure that the output is really
utf\-8.  You should only use it, if you have set the environment
variable \fB\s-1OUTPUT_CHARSET\s0\fR to \*(L"utf\-8\*(R".  Additionally you should
call \fIbind_textdomain_codeset()\fR with \*(L"utf\-8\*(R" as the second
argument.
.Sp
Steven Haryanto has written a module \fILocale::TextDomain::UTF8\fR\|(3pm)
that addresses the same problem.
.Sp
This function has been introduced in libintl-perl 1.16 and it is
\&\fBnot\fR part of the standard gettext \s-1API.\s0
.IP "\fBturn_utf_8_on \s-1VARIABLE\s0\fR" 4
.IX Item "turn_utf_8_on VARIABLE"
Returns \s-1VARIABLE\s0 but with the \s-1UTF\-8\s0 flag (only known in Perl >=5.6)
guaranteed to be turned on.  This function does not really fit into
the module, but it is often handy nevertheless.
.Sp
The flag does \fBnot\fR mean that the string is in fact valid utf\-8!
.Sp
The function was introduced with libintl-perl version 1.16.
.IP "\fBturn_utf_8_off \s-1VARIABLE\s0\fR" 4
.IX Item "turn_utf_8_off VARIABLE"
Returns \s-1VARIABLE\s0 but with the \s-1UTF\-8\s0 flag (only known in Perl >=5.6)
guaranteed to be turned off.  This function does not really fit into
the module, but it is often handy nevertheless.
.Sp
The function was introduced with libintl-perl version 1.07.
.IP "\fBselect_package \s-1PACKAGE\s0\fR" 4
.IX Item "select_package PACKAGE"
By default, \fBLocale::Messages\fR will try to load the \s-1XS\s0 version of
the gettext implementation, i. e. \fILocale::gettext_xs\fR\|(3) and will fall
back to the pure Perl implementation \fILocale::gettext_pp\fR\|(3).  You can
override this behavior by passing the string \*(L"gettext_pp\*(R" or
\&\*(L"gettext_xs\*(R" to the function \fIselect_package()\fR.  Passing \*(L"gettext_pp\*(R"
here, will prefer the pure Perl implementation.
.Sp
You will normally want to use that in a \s-1BEGIN\s0 block of your main
script.
.Sp
The function was introduced with libintl-perl version 1.03 and is not
part of the standard gettext \s-1API.\s0
.Sp
Beginning with version 1.22 you can pass other package names than \*(L"gettext_pp\*(R"
or \*(L"gettext_xs\*(R" and use a completely different backend.  It is the caller's
responsability to make sure that the selected package offers the same
interface as the two standard packages.
.Sp
One package that offers that functionality is \fILocale::gettext_dumb\fR\|(3pm).
.IP "\fBnl_putenv \s-1ENVSPEC\s0\fR" 4
.IX Item "nl_putenv ENVSPEC"
Resembles the \s-1ANSI C\s0 \fIputenv\fR\|(3) function.  The sole purpose of this 
function is to work around some ideosyncrasies in the environment
processing of Windows systems.  If you want to portably set or
unset environment variables, use this function instead of directly
manipulating \f(CW%ENV\fR.
.Sp
The argument \fB\s-1ENVSPEC\s0\fR may have three different forms.
.RS 4
.IP "\fBLANGUAGE=fr_CH\fR" 8
.IX Item "LANGUAGE=fr_CH"
This would set the environment variable \f(CW\*(C`LANGUAGE\*(C'\fR to \*(L"fr_CH\*(R".
.IP "\fBLANGUAGE=\fR" 8
.IX Item "LANGUAGE="
Normally, this will set the environment variable \f(CW\*(C`LANGUAGE\*(C'\fR to an
empty string.  Under Windows, however, the environment variable will
be deleted instead (and is no longer present in \f(CW%ENV\fR).  Since
within libintl-perl empty environment variables are useless, consider
this usage as deprecated.
.IP "\fB\s-1LANGUAGE\s0\fR" 8
.IX Item "LANGUAGE"
This will delete the environment variable \fB\s-1LANGUAGE\s0\fR.  If you are
familiar with the brain-damaged implementation of \fIputenv\fR\|(3) (resp.
\&\fI_putenv()\fR) in the so-called standard C library of MS-Windows, you
may suspect that this is an invalid argument.  This is not the case!
Passing a variable name not followed by an equal sign will always
delete the variable, no matter which operating system you use.
.RE
.RS 4
.Sp
The function returns true for success, and false for failure.  Possible
reasons for failure are an invalid syntax or \- only under Windows \-
failure to allocate space for the new environment entry ($! will be
set accordingly in this case).
.Sp
Why all this hassle?  The 32\-bit versions of MS-DOS (currently
Windows 95/98/ME/NT/2000/XP/CE/.NET) maintain two distinct blocks
of environment variables per process.  Which block is considered
the \*(L"correct\*(R" environment is a compile-time option of the Perl
interpreter.  Unfortunately, if you have build the \s-1XS\s0 version 
\&\fILocale::gettext_xs\fR\|(3) under Windows, the underlying library may use 
a different environment block, and changes you make to \f(CW%ENV\fR may
not be visible to the library.
.Sp
The function \fInl_putenv()\fR is mostly a funny way of saying
.Sp
.Vb 1
\&    LANGUAGE=some_value
.Ve
.Sp
but it does its best, to pass this information to the gettext 
library.  Under other operating systems than Windows, it only
operates on \f(CW%ENV\fR, under Windows it will call the C library
function \fI_putenv()\fR (after doing some cleanup to its arguments),
before manipulating \f(CW%ENV\fR.
.Sp
Please note, that your \f(CW%ENV\fR is updated by \fInl_putenv()\fR automatically.
.Sp
The function has been introduced in libintl-perl version 1.10.
.RE
.IP "setlocale" 4
.IX Item "setlocale"
Modifies and queries program's locale, see the documentation for \fIsetlocale()\fR
in \s-1\fIPOSIX\s0\fR\|(3pm) instead.
.Sp
On some systems, when using \s-1GNU\s0 gettext, a call from C to \fIsetlocale()\fR is
\&\- with the help of the C preprocessor \- really a call to \fIlibintl_setlocale()\fR,
which is in turn a wrapper around the system \fIsetlocale\fR\|(3).  Failure to call
\&\fIlibintl_setlocale()\fR may lead to certain malfunctions.  On such systems,
\&\fB\f(BILocale::Messages::setlocale()\fB\fR will call the wrapper \fIlibintl_setlocale()\fR.
If you want to avoid problems, you should therefore always call
the \fIsetlocale()\fR implementation in \fILocale::Messages\fR\|(3pm).
.Sp
See <https://rt.cpan.org/Public/Bug/Display.html?id=83980> or
<https://savannah.gnu.org/bugs/?38162>, and 
<https://savannah.gnu.org/bugs/?func=detailitem&item_id=44645> for a discussion
of the problem.
.Sp
The function has been introduced in libintl-perl version 1.24.
.SH "CONSTANTS"
.IX Header "CONSTANTS"
You can (maybe) get the same constants from \s-1\fIPOSIX\s0\fR\|(3); see there for
a detailed description
.IP "\fB\s-1LC_CTYPE\s0\fR" 4
.IX Item "LC_CTYPE"
.PD 0
.IP "\fB\s-1LC_NUMERIC\s0\fR" 4
.IX Item "LC_NUMERIC"
.IP "\fB\s-1LC_TIME\s0\fR" 4
.IX Item "LC_TIME"
.IP "\fB\s-1LC_COLLATE\s0\fR" 4
.IX Item "LC_COLLATE"
.IP "\fB\s-1LC_MONETARY\s0\fR" 4
.IX Item "LC_MONETARY"
.IP "\fB\s-1LC_MESSAGES\s0\fR" 4
.IX Item "LC_MESSAGES"
.PD
This locale category was the reason that these constants from \s-1\fIPOSIX\s0\fR\|(3)
were included here.  Even if it was present in your systems C include
file \fIlocale.h\fR, it was not provided by \s-1\fIPOSIX\s0\fR\|(3).  Perl 5.8 and later
seems to export the constant if available, although it is not documented
in \s-1\fIPOSIX\s0\fR\|(3).
.Sp
\&\fILocale::Messages\fR\|(3) makes an attempt to guess the value of this category for
all systems, and assumes the arbitrary value 1729 otherwise.
.IP "\fB\s-1LC_ALL\s0\fR" 4
.IX Item "LC_ALL"
If you specify the category \fB\s-1LC_ALL\s0\fR as the first argument to
\&\fIPOSIX::setlocale()\fR, \fIall\fR locale categories will be affected at once.
.SH "EXPORT TAGS"
.IX Header "EXPORT TAGS"
The module does not export anything unless explicitely requested.
You can import groups of functions via two tags:
.IP "\fBuse Locale::Messages (':locale_h')\fR" 4
.IX Item "use Locale::Messages (':locale_h')"
Imports the functions that are normally defined in the C include
file \fIlocale.h\fR:
.RS 4
.IP "\fB\f(BIgettext()\fB\fR" 8
.IX Item "gettext()"
.PD 0
.IP "\fB\f(BIdgettext()\fB\fR" 8
.IX Item "dgettext()"
.IP "\fB\f(BIdcgettext()\fB\fR" 8
.IX Item "dcgettext()"
.IP "\fB\f(BIngettext()\fB\fR" 8
.IX Item "ngettext()"
.IP "\fB\f(BIdngettext()\fB\fR" 8
.IX Item "dngettext()"
.IP "\fB\f(BIdcngettext()\fB\fR" 8
.IX Item "dcngettext()"
.IP "\fB\f(BIpgettext()\fB\fR" 8
.IX Item "pgettext()"
.IP "\fB\f(BIdpgettext()\fB\fR" 8
.IX Item "dpgettext()"
.IP "\fB\f(BIdcpgettext()\fB\fR" 8
.IX Item "dcpgettext()"
.IP "\fB\f(BInpgettext()\fB\fR" 8
.IX Item "npgettext()"
.IP "\fB\f(BIdnpgettext()\fB\fR" 8
.IX Item "dnpgettext()"
.IP "\fB\f(BIdcnpgettext()\fB\fR" 8
.IX Item "dcnpgettext()"
.IP "\fB\f(BItextdomain()\fB\fR" 8
.IX Item "textdomain()"
.IP "\fB\f(BIbindtextdomain()\fB\fR" 8
.IX Item "bindtextdomain()"
.IP "\fB\f(BIbind_textdomain_codeset()\fB\fR" 8
.IX Item "bind_textdomain_codeset()"
.RE
.RS 4
.RE
.IP "\fBuse Locale::Messages (':libintl_h')\fR" 4
.IX Item "use Locale::Messages (':libintl_h')"
.PD
Imports the locale category constants:
.RS 4
.IP "\fB\s-1LC_CTYPE\s0\fR" 8
.IX Item "LC_CTYPE"
.PD 0
.IP "\fB\s-1LC_NUMERIC\s0\fR" 8
.IX Item "LC_NUMERIC"
.IP "\fB\s-1LC_TIME\s0\fR" 8
.IX Item "LC_TIME"
.IP "\fB\s-1LC_COLLATE\s0\fR" 8
.IX Item "LC_COLLATE"
.IP "\fB\s-1LC_MONETARY\s0\fR" 8
.IX Item "LC_MONETARY"
.IP "\fB\s-1LC_MESSAGES\s0\fR" 8
.IX Item "LC_MESSAGES"
.IP "\fB\s-1LC_ALL\s0\fR" 8
.IX Item "LC_ALL"
.RE
.RS 4
.RE
.PD
.SH "OTHER EXPORTS"
.IX Header "OTHER EXPORTS"
.IP "\fBselect_package \s-1PACKAGE\s0\fR" 4
.IX Item "select_package PACKAGE"
.SH "USAGE"
.IX Header "USAGE"
A complete example:
.PP
.Vb 7
\&    1: use Locale::Messages qw(:locale_h :libintl_h);
\&    2: use POSIX qw (setlocale);
\&    3: setlocale (LC_MESSAGES, \*(Aq\*(Aq);
\&    4: textdomain (\*(Aqmy\-package\*(Aq);
\&    5: bindtextdomain (\*(Aqmy\-package\*(Aq => \*(Aq/usr/local/share/locale\*(Aq);
\&    6:
\&    7: print gettext ("Hello world!\en");
.Ve
.PP
Step by step: Line 1 imports the necessary functions and constants.
In line 3 we set the locale for category \s-1LC_MESSAGES\s0 to the default
user settings.  For C programs you will often read that \s-1LC_ALL\s0
is the best category here but this will also change the locale for
\&\s-1LC_NUMERIC\s0 and many programs will not work reliably after changing
that category in Perl; choose your own poison!
.PP
In line 4 we say that all messages (translations) without an explicit
domain specification should be retrieved from the message catalog
for the domain 'my\-package'.  Line 5 has the effect that the message
catalog will be searched under the directory \fI/usr/local/share/locale\fR.
.PP
If the user has selected the locale 'fr_CH', and if the file 
\&\fI/usr/local/share/locale/fr_CH/LC_MESSAGES/my\-package.mo\fR
exists, and if it contains a \s-1GNU\s0 message object file with a translation
for the string \*(L"Hello world!\en\*(R", then line 7 will print the French
translation (for Switzerland \s-1CH\s0) to \s-1STDOUT.\s0
.PP
The documentation for \s-1GNU\s0 gettext explains how to extract translatable
strings from your Perl files and how to create message catalogs.
.PP
Another less portable example: If your system uses the \s-1GNU\s0 libc you
should be able to find various files with the name \fIlibc.mo\fR, the
message catalog for the library itself.  If you have found these
files under \fI/usr/share/locale\fR, then you can try the following:
.PP
.Vb 2
\&    use Locale::Messages qw(:locale_h :libintl_h);
\&    use POSIX qw (setlocale);
\&
\&    setlocale LC_MESSAGES, "";
\&    textdomain "libc";
\&
\&    # The following is actually not needed, since this is
\&    # one of the default search directories.
\&    bindtextdomain libc => \*(Aq/usr/share/locale\*(Aq;
\&    bind_textdomain_codeset libc => \*(Aqiso\-8859\-1\*(Aq;
\&
\&    print gettext ("No such file or directory");
.Ve
.PP
See \fILocale::TextDomain\fR\|(3) for much simpler ways.
.SH "AUTHOR"
.IX Header "AUTHOR"
Copyright (C) 2002\-2017 Guido Flohr <http://www.guido-flohr.net/>
(<mailto:guido.flohr@cantanea.com>), all rights reserved.  See the source
code for details!code for details!
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fILocale::TextDomain\fR\|(3pm), \fILocale::gettext_pp\fR\|(3pm), \fIEncode\fR\|(3pm),
\&\fIperllocale\fR\|(3pm), \s-1\fIPOSIX\s0\fR\|(3pm), \fIperl\fR\|(1), \fIgettext\fR\|(1), \fIgettext\fR\|(3)
.SH "POD ERRORS"
.IX Header "POD ERRORS"
Hey! \fBThe above document had some coding errors, which are explained below:\fR
.IP "Around line 1002:" 4
.IX Item "Around line 1002:"
\&'=item' outside of any '=over'
.IP "Around line 1004:" 4
.IX Item "Around line 1004:"
You forgot a '=back' before '=head1'
