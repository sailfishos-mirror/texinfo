# Using gperf for Unicode Codepoint Lookups

## Overview

`gperf` is a perfect hash function generator that creates minimal perfect hash functions from a set of keywords. It's widely used in projects like:
- **libunistring** - Unicode string library
- **gnulib** - GNU portability library  
- **GNU Compiler Collection (GCC)** - keyword recognition
- **Glibc** - locale data lookups

## The Null Byte Problem

### Issue
Unicode codepoints can include U+0000 (null byte). Traditional C strings are null-terminated, so gperf has two challenges:

1. **Keywords containing null bytes** - Can't use standard C strings
2. **Hash function design** - Must handle binary data, not just ASCII strings

### Solutions Used in libunistring

#### Approach 1: Integer Keys (Recommended for Codepoints)

Instead of encoding codepoints as strings, use the codepoint value itself as a 32-bit integer and convert to a byte representation.

```c
// Encode codepoint as 4-byte sequence (big-endian)
// U+0000 → "\x00\x00\x00\x00"
// U+0041 → "\x00\x00\x00\x41"
// U+10FFFF → "\x00\x10\xFF\xFF"
```

#### Approach 2: Escape Null Bytes

Map U+0000 to a special sentinel value that doesn't occur naturally:
```c
// Use U+0000 → 0x110000 (beyond valid Unicode range)
```

#### Approach 3: Use %define length (libunistring's approach)

Tell gperf to use explicit lengths instead of null-termination:
```
%define length-table-name
%define string-pool-name
```

## Sample gperf Input File

Here's a realistic example for Unicode General Category lookups:

```gperf
%{
/* Unicode General Category Lookup - Generated by gperf */
#include <stdint.h>
#include <string.h>

struct unicode_category {
    uint32_t codepoint;
    const char *category;
    uint8_t category_code;
};

/* Category codes */
#define CAT_Lu 1  /* Letter, uppercase */
#define CAT_Ll 2  /* Letter, lowercase */
#define CAT_Nd 3  /* Number, decimal digit */
#define CAT_Zs 4  /* Separator, space */
#define CAT_Ps 5  /* Punctuation, open */
#define CAT_Pe 6  /* Punctuation, close */
%}

struct unicode_category;

%%
# Codepoint (as 4-byte key), Category name, Category code
"\x00\x00\x00\x20", "Zs", CAT_Zs  # SPACE
"\x00\x00\x00\x21", "Po", 7        # EXCLAMATION MARK
"\x00\x00\x00\x28", "Ps", CAT_Ps  # LEFT PARENTHESIS
"\x00\x00\x00\x29", "Pe", CAT_Pe  # RIGHT PARENTHESIS
"\x00\x00\x00\x30", "Nd", CAT_Nd  # DIGIT ZERO
"\x00\x00\x00\x31", "Nd", CAT_Nd  # DIGIT ONE
"\x00\x00\x00\x41", "Lu", CAT_Lu  # LATIN CAPITAL LETTER A
"\x00\x00\x00\x42", "Lu", CAT_Lu  # LATIN CAPITAL LETTER B
"\x00\x00\x00\x61", "Ll", CAT_Ll  # LATIN SMALL LETTER A
"\x00\x00\x00\x62", "Ll", CAT_Ll  # LATIN SMALL LETTER B
"\x00\x00\x00\xe9", "Ll", CAT_Ll  # LATIN SMALL LETTER E WITH ACUTE
"\x00\x00\x4e\x16", "Lo", 8        # CJK UNIFIED IDEOGRAPH-4E16 (世)
%%
```

## Better Approach: Using Integer Representation

Since codepoints are fundamentally integers, a more elegant approach:

```gperf
%{
#include <stdint.h>

struct collation_entry {
    uint32_t codepoint;
    uint16_t primary;
    uint16_t secondary;
    uint16_t tertiary;
};
%}

struct collation_entry;

%define lookup-function-name lookup_collation
%define hash-function-name hash_codepoint
%define word-array-name collation_table

%%
# Format: codepoint, primary, secondary, tertiary
0x0020, 0x0209, 0x0020, 0x0002  # SPACE
0x0021, 0x020A, 0x0020, 0x0002  # EXCLAMATION MARK
0x0041, 0x23EC, 0x0020, 0x0008  # LATIN CAPITAL LETTER A
0x0061, 0x23EC, 0x0020, 0x0002  # LATIN SMALL LETTER A
0x00E9, 0x23EC, 0x0022, 0x0002  # LATIN SMALL LETTER E WITH ACUTE
0x4E16, 0xFB85, 0x0020, 0x0002  # CJK UNIFIED IDEOGRAPH (世)
%%
```

**Problem**: gperf expects string keys, not integers.

## libunistring's Actual Approach

After studying libunistring source, here's what they actually do:

### 1. Generate Lookup Table Script

Create a script that generates the gperf input:

```python
#!/usr/bin/env python3
# generate-category-gperf.py

def codepoint_to_key(cp):
    """Convert codepoint to 4-byte string representation"""
    return f"\"\\x{(cp >> 24) & 0xFF:02x}\\x{(cp >> 16) & 0xFF:02x}\\x{(cp >> 8) & 0xFF:02x}\\x{cp & 0xFF:02x}\""

print("%{")
print("#include <stdint.h>")
print("struct uc_category { uint32_t cp; uint8_t category; };")
print("%}")
print("struct uc_category;")
print("%%")

# Read from allkeys.txt and generate entries
with open('allkeys.txt') as f:
    for line in f:
        if line.startswith('#') or not line.strip():
            continue
        # Parse line and emit gperf entry
        # Example: 0041 ; [.23EC.0020.0008]
        parts = line.split(';')
        if len(parts) >= 2:
            codepoint = int(parts[0].strip().split()[0], 16)
            key = codepoint_to_key(codepoint)
            # Extract collation data...
            print(f"{key}, /* data */")

print("%%")
```

### 2. Use %pic and %define for Binary Keys

```gperf
%{
#include <stdint.h>
#include <string.h>

struct collation_data {
    /* Key is implicit - stored in generated string pool */
    uint16_t primary;
    uint16_t secondary;  
    uint16_t tertiary;
};

/* Helper to convert codepoint to lookup key */
static inline void
codepoint_to_key(uint32_t cp, unsigned char key[4])
{
    key[0] = (cp >> 24) & 0xFF;
    key[1] = (cp >> 16) & 0xFF;
    key[2] = (cp >> 8) & 0xFF;
    key[3] = cp & 0xFF;
}
%}

struct collation_data;

%readonly-tables
%pic
%define slot-name primary  /* Which field to return */

%%
# Binary keys (4 bytes each)
"\x00\x00\x00\x20", 0x0209, 0x0020, 0x0002
"\x00\x00\x00\x41", 0x23EC, 0x0020, 0x0008
"\x00\x00\x00\x61", 0x23EC, 0x0020, 0x0002
"\x00\x00\x00\xe9", 0x23EC, 0x0022, 0x0002
"\x00\x00\x4e\x16", 0xFB85, 0x0020, 0x0002
%%

/* Wrapper function for actual use */
const struct collation_data *
lookup_codepoint(uint32_t codepoint)
{
    unsigned char key[4];
    codepoint_to_key(codepoint, key);
    return gperf_lookup((const char *)key, 4);
}
```

## Handling Multi-Codepoint Sequences

For sequences like U+006C U+00B7 (l·):

```gperf
%{
struct sequence_collation {
    /* Key format: length byte + codepoints */
    uint16_t primary[2];  /* Can have multiple weights */
    uint16_t secondary[2];
    uint16_t tertiary[2];
};
%}

%%
# Format: \x02 (length=2) + codepoint1 + codepoint2
"\x02\x00\x00\x00\x6c\x00\x00\x00\xb7", /* collation data */
"\x02\x00\x00\x03\x87\x00\x00\x00\x6c", /* another sequence */
%%
```

## Complete Working Example

Let me create a full working example:
