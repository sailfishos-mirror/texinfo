%{
/* 
 * Unicode General Category Perfect Hash Lookup
 * Generated for demonstration purposes
 */
#include <stdint.h>
#include <string.h>

/* Unicode General Category structure */
struct unicode_category {
    uint32_t codepoint;  /* For reference */
    const char *name;    /* "Lu", "Ll", "Nd", etc. */
    uint8_t code;        /* Numeric category code */
};

/* Category codes */
#define UC_LETTER_UPPERCASE     1
#define UC_LETTER_LOWERCASE     2  
#define UC_NUMBER_DECIMAL       3
#define UC_PUNCTUATION_OPEN     4
#define UC_PUNCTUATION_CLOSE    5
#define UC_SEPARATOR_SPACE      6
#define UC_PUNCTUATION_OTHER    7
#define UC_LETTER_OTHER         8
%}

struct unicode_category;

%readonly-tables
%language=C
%struct-type
%define lookup-function-name lookup_category_internal

%%
# Key format: 4-byte big-endian codepoint
# Note: gperf will see these as string literals of length 4

# ASCII punctuation and digits
"\x00\x00\x00\x20", 0x00000020, "Zs", UC_SEPARATOR_SPACE
"\x00\x00\x00\x21", 0x00000021, "Po", UC_PUNCTUATION_OTHER
"\x00\x00\x00\x28", 0x00000028, "Ps", UC_PUNCTUATION_OPEN
"\x00\x00\x00\x29", 0x00000029, "Pe", UC_PUNCTUATION_CLOSE
"\x00\x00\x00\x30", 0x00000030, "Nd", UC_NUMBER_DECIMAL
"\x00\x00\x00\x31", 0x00000031, "Nd", UC_NUMBER_DECIMAL
"\x00\x00\x00\x32", 0x00000032, "Nd", UC_NUMBER_DECIMAL
"\x00\x00\x00\x33", 0x00000033, "Nd", UC_NUMBER_DECIMAL
"\x00\x00\x00\x34", 0x00000034, "Nd", UC_NUMBER_DECIMAL
"\x00\x00\x00\x35", 0x00000035, "Nd", UC_NUMBER_DECIMAL
"\x00\x00\x00\x36", 0x00000036, "Nd", UC_NUMBER_DECIMAL
"\x00\x00\x00\x37", 0x00000037, "Nd", UC_NUMBER_DECIMAL
"\x00\x00\x00\x38", 0x00000038, "Nd", UC_NUMBER_DECIMAL
"\x00\x00\x00\x39", 0x00000039, "Nd", UC_NUMBER_DECIMAL

# ASCII letters
"\x00\x00\x00\x41", 0x00000041, "Lu", UC_LETTER_UPPERCASE
"\x00\x00\x00\x42", 0x00000042, "Lu", UC_LETTER_UPPERCASE
"\x00\x00\x00\x43", 0x00000043, "Lu", UC_LETTER_UPPERCASE
"\x00\x00\x00\x5a", 0x0000005A, "Lu", UC_LETTER_UPPERCASE
"\x00\x00\x00\x61", 0x00000061, "Ll", UC_LETTER_LOWERCASE
"\x00\x00\x00\x62", 0x00000062, "Ll", UC_LETTER_LOWERCASE
"\x00\x00\x00\x63", 0x00000063, "Ll", UC_LETTER_LOWERCASE
"\x00\x00\x00\x7a", 0x0000007A, "Ll", UC_LETTER_LOWERCASE

# Latin-1 Supplement
"\x00\x00\x00\xe0", 0x000000E0, "Ll", UC_LETTER_LOWERCASE
"\x00\x00\x00\xe1", 0x000000E1, "Ll", UC_LETTER_LOWERCASE
"\x00\x00\x00\xe9", 0x000000E9, "Ll", UC_LETTER_LOWERCASE
"\x00\x00\x00\xc0", 0x000000C0, "Lu", UC_LETTER_UPPERCASE
"\x00\x00\x00\xc1", 0x000000C1, "Lu", UC_LETTER_UPPERCASE

# CJK examples (demonstrating 3-byte UTF-8 range)
"\x00\x00\x4e\x00", 0x00004E00, "Lo", UC_LETTER_OTHER
"\x00\x00\x4e\x16", 0x00004E16, "Lo", UC_LETTER_OTHER
"\x00\x00\x4e\x2d", 0x00004E2D, "Lo", UC_LETTER_OTHER

# Emoji/Symbols (demonstrating 4-byte UTF-8 range)
"\x00\x01\xf6\x00", 0x0001F600, "So", 9
"\x00\x01\xf3\x0d", 0x0001F30D, "So", 9

%%

/*
 * Public API function - converts codepoint to lookup key
 */
const struct unicode_category *
lookup_unicode_category(uint32_t codepoint)
{
    unsigned char key[4];
    
    /* Convert codepoint to big-endian 4-byte key */
    key[0] = (codepoint >> 24) & 0xFF;
    key[1] = (codepoint >> 16) & 0xFF;
    key[2] = (codepoint >> 8) & 0xFF;
    key[3] = codepoint & 0xFF;
    
    /* Use generated perfect hash lookup */
    return lookup_category_internal((const char *)key, 4);
}
